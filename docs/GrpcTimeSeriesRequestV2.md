# GrpcTimeSeriesRequestV2

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**end** | **datetime** | We specify query time ranges with a tuple of (end, duration, num_steps).  From these values, we compute:    - step_sec &#x3D; duration / num_steps    - start &#x3D; end - (step_sec * num_steps)  The returned timeseries will contain points between start and end that are evenly spaced at step_sec. More precisely, points[i] will correspond to the range: ((start + (step_sec * i)), (start + step_sec * (i + 1)].  We enforce the following constraints on all queries:    - end is expected to be in the UTC timezone    - end must be at or before the current time    - duration must be less than some MAX_QUERY_DURATION, currently 2 days    - duration must be an integral number of seconds    - duration / num_steps must result in an integral number of samples    [1]    - duration / num_steps must be less than some MAX_NUM_SAMPLES    - num_steps must be less than MAX_NUM_POINTS (about 1000)  [1] We currently store data at 5sec, 30sec, and 600sec samples. So, when we derive step &#x3D; duration / num_steps, we enfore that step is either:    - a multiple of 5s if &lt; 30s as we read from the 5sec data, or    - a multiple of 30s if &gt; 30s and &lt; 600s as we read from the 30sec    data,    - a multiple of 600s if &gt; 600s as we read from the 600sec data.  Queries that violate any of these constraints will result in an INVALID_ARGUMENT error. | [optional] 
**duration** | **str** |  | [optional] 
**num_steps** | **int** |  | [optional] 
**source_filters** | [**list[GrpcFilter]**](GrpcFilter.md) | Lists of filters for the source and destinations.  The &#x60;directionality&#x60;field determines how these labels get converted to labels queried against the backing TSDB.  For instance, if we query for    - source_filters &#x3D; [{&#39;role&#39;, IN [&#39;my-role&#39;]} and    - destination_filters &#x3D; [{&#39;az&#39;, IN, [&#39;my-az&#39;]}] Then they potentially get reversed with directionality:   - FORWARD, then these are executed as written.   - BACKWARD, then these become:       - source_filters &#x3D; [{&#39;az&#39;, IN, [&#39;my-az&#39;]}]       - destination_filters &#x3D; [{&#39;role&#39;, IN [&#39;my-role&#39;]}]   - BOTH, then both of the above queries are done and the results are        merged together. | [optional] 
**destination_filters** | [**list[GrpcFilter]**](GrpcFilter.md) |  | [optional] 
**metric** | **str** | Metric to return as timeseries.  We return metrics as durations, percents, or rates. A good rule of thumb for how to interpret metric values is: - metrics suffixed with _latency are in seconds, - metrics suffixed with _percent are percents of totals, and - all other metrics are rates, such as \&quot;bytes per second\&quot; or   \&quot;udp_packets per second\&quot; or \&quot;http_code_200 per second.\&quot; | [optional] 
**source_grouping** | **list[str]** | A list of labels that the returned timeseries will include.  Queries must specify at least one grouping on either the source or destination side.  If only one side of the groupings are specified, then the returned timeseries will be aggregated for that one side, e.g., if we specify a query for source_grouping &#x3D; [&#39;id&#39;], then the returned timeseries will be the sum of the specified metric aggregated by source address.  Note: The response&#39;s &#x60;series.source_labels&#x60; and &#x60;series.destination_labels&#x60; will contain &#x60;source_grouping&#x60; and &#x60;destination_grouping&#x60;, for both FORWARD and REVERSED responses, i.e., reversed timeseries don&#39;t reverse the source and destination grouping labels. | [optional] 
**destination_grouping** | **list[str]** |  | [optional] 
**directionality** | [**GrpcDirectionality**](GrpcDirectionality.md) | Used to conditionally reverse the specified filters. | [optional] 
**top_k** | **int** | Maximum number of time series to return. Defaults to 30 if unspecified. If set to -1, then we&#39;ll return all timeseries.  When requesting directionality FORWARD or REVERSE, then we will return no more than k timeseries. If requesting directionality BOTH, then we&#39;ll return at most 2*k timeseries, which include the k FORWARD timeseries and their corresponding REVERSE timeseries. | [optional] 
**no_rollups** | **bool** | Flag to manually disable the use of time-aggregated data.  Our default TSDB stores samples at 1sec resoltuion. Our \&quot;rolled up\&quot; TSDB stores data at 30s or 600s resolution. | [optional] 
**label_equality** | [**list[GrpcLabelEqualityPair]**](GrpcLabelEqualityPair.md) | Query structure to perform &#39;!&#x3D;&#39; or &#39;&#x3D;&#x3D;&#39; operations on a subset of timeseries labels.  We commonly use these to query for cross-zone traffic, which looks like { \&quot;label\&quot;: \&quot;az\&quot;, \&quot;equal\&quot;: false }. | [optional] 
**no_zero_padding** | **bool** | Controls how we compute latency timeseries values when there are no samples in a given time range.  If true, then the value of latencies in time ranges with no samples will be marked with a -1.  Otherwise, latency timeseries will be filled with 0s when we have no samples. This is the default behavior to ensure backward compatability.  Beware: the default behavior makes it impossible to differentiate between \&quot;0 measurements\&quot; and \&quot;measured 0.\&quot;  This applies only to latency metrics because we use \&quot;no samples\&quot; to mean 0 for for all other metrics, such as rates and percents. | [optional] 

[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)


